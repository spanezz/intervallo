#!/usr/bin/python3

# Given image files on input, generates a video in the style of Intervallo RAI.
# For audio, you can use https://archive.org/details/IntervalloRai-Paradisi

import argparse
import os
import PIL
import PIL.ImageFont, PIL.ImageDraw, PIL.ImageFilter, PIL.ImageEnhance
import subprocess
import tempfile
import shlex

class Input:
    def __init__(self, parent, pathname):
        self.parent = parent
        self.pathname = pathname
        if os.path.exists(self.pathname + ".txt"):
            with open(self.pathname + ".txt", "rt") as fd:
                self.subtitle = [x.strip() for x in fd.readlines()]
        else:
            self.subtitle = [os.path.splitext(os.path.basename(self.pathname))[0]]
        self.video_file = tempfile.NamedTemporaryFile(mode="wb", dir=".", suffix=".mp4")
        self.video_pathname = os.path.basename(self.video_file.name)

    def text_frame(self):
        # Draw the subtitle on the image
        txtimg = PIL.Image.new("RGBA", (self.parent.frame_x, self.parent.frame_y), (0, 0, 0, 0))
        draw = PIL.ImageDraw.Draw(txtimg)
        subtitles = [(line, draw.textsize(line, self.parent.font)) for line in self.subtitle]
        y = self.parent.frame_y - 50
        for line, size in subtitles[::-1]:
            y -= size[1] + 10
            draw.text(((self.parent.frame_x - size[0]) / 2, y), line, fill=(200, 200, 200), font=self.parent.font)
            # Draw it again a bit offset, then blur, to simulate text being slightly out of focus
            draw.text(((self.parent.frame_x - size[0]) / 2 + 1, y + 1), line, fill=(200, 200, 200), font=self.parent.font)
        txtimg = txtimg.filter(PIL.ImageFilter.GaussianBlur(radius=1))

        return txtimg

    def to_frame(self):
        src = PIL.Image.open(self.pathname)

        # Scale the image to our frame size
        src.thumbnail((self.parent.frame_x, self.parent.frame_y), PIL.Image.ANTIALIAS)

        # Add vignette effect
        vignette = PIL.Image.new("L", src.size, "black")
        vignette_draw = PIL.ImageDraw.Draw(vignette)
        vignette_draw.ellipse(((0, 0), vignette.size), fill="white")
        vignette = vignette.filter(PIL.ImageFilter.GaussianBlur(radius=100))
        black = PIL.Image.new("RGB", vignette.size, "black")
        src = PIL.Image.composite(src, black, vignette)

        # Image with black background
        img = PIL.Image.new("RGBA", (self.parent.frame_x, self.parent.frame_y), "black")

        # Center the source image over the black background
        img.paste(src, (((self.parent.frame_x - src.size[0]) // 2), ((self.parent.frame_y - src.size[1]) // 2)))

        # Draw the subtitle on the image
        img = PIL.Image.alpha_composite(img, self.text_frame())

        if self.parent.bw:
            # Convert to to grayscale
            img = img.convert("LA")
        else:
            # Desaturate
            desaturate = PIL.ImageEnhance.Color(img)
            img = desaturate.enhance(0.5)

        if False:
            img.show()
            import sys
            sys.exit(1)

        return img

    def to_video(self):
        if os.path.getsize(self.video_pathname) > 0: return

        img = self.to_frame()

        ## Turn the image into a movie segment
        with tempfile.NamedTemporaryFile(mode="wb", dir=".", suffix=".png") as fimg:
            with tempfile.NamedTemporaryFile(mode="wb", dir=".", suffix=".mp4") as ffadein:
                img.save(fimg.name)
                cmd = ["ffmpeg", "-loop", "1", "-i", fimg.name, "-c:v", "libx264",
                        "-framerate", "25",
                        "-t", str(self.parent.duration), "-pix_fmt", "yuv420p",
                        "-vf", "fade=in:0:25",
                        "-y", ffadein.name]
                subprocess.check_call(cmd)

                cmd = ["ffmpeg", "-i", ffadein.name,
                        "-vf", "fade=out:{}:25".format(self.parent.duration * 25 - 25),
                        "-y", self.video_pathname]
                subprocess.check_call(cmd)


class Intervallo:
    def __init__(self, font, audio, duration, output, bw):
        self.font = PIL.ImageFont.truetype(font, 40)
        self.audio_pathname = audio
        self.output_pathname = output
        self.frame_x = 704
        self.frame_y = 576
        self.duration = duration
        self.bw = bw
        self.files = []

    def get_subtitle(self, pathname):
        return os.path.splitext(os.path.basename(pathname))[0]

    def process(self, files):
        has_audio = bool(self.audio_pathname)
        with tempfile.NamedTemporaryFile(mode="wb", dir=".", suffix=".mp4", delete=has_audio) as mute:
            with tempfile.NamedTemporaryFile(mode="wt", dir=".", suffix=".txt") as flist:
                for pathname in files:
                    f = Input(self, pathname)
                    f.to_video()
                    self.files.append(f)
                    quoted = shlex.quote(f.video_pathname)
                    if quoted[0] != "'":
                        quoted = "'{}'".format(quoted)
                    print("file {}".format(quoted), file=flist)

                flist.flush()

                subprocess.check_call(["cat", flist.name])

                cmd = ["ffmpeg", "-y", "-f", "concat", "-i", flist.name, "-c", "copy", mute.name]
                subprocess.check_call(cmd)

            if has_audio:
                cmd = ["ffmpeg", "-y", "-i", mute.name, "-i", self.audio_pathname, "-codec", "copy", "-shortest", self.output_pathname]
                subprocess.check_call(cmd)
            else:
                os.rename(mute.name, self.output_pathname)


def main():
    parser = argparse.ArgumentParser(description="Create an Intervallo RAI out of a collection of images.")
    parser.add_argument("--font", metavar="file.ttf", default="lmromandemi10-regular.otf", help="Font to use for subtitles")
    parser.add_argument("--audio", metavar="file.mp3", help="Audio track")
    parser.add_argument("--duration", metavar="sec", type=int, default=5, help="Time for each image in seconds")
    parser.add_argument("--bw", action="store_true", help="Black and white instead of desaturated colours")
    parser.add_argument("-o", "--output", metavar="pathname", default="intervallo.mp4", help="Output file name")
    parser.add_argument("imgfile", nargs="+", help="input image files")
    args = parser.parse_args()

    proc = Intervallo(font=args.font, audio=args.audio, duration=args.duration, output=args.output, bw=args.bw)
    proc.process([x for x in args.imgfile if not x.endswith(".txt")])


if __name__ == "__main__":
    main()

